// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(libgossipFFI)
import libgossipFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_libgossip_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_libgossip_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol AppHostProtocol : AnyObject {
    
    func blobs()  -> BlobDataDispatcher
    
    func global(viewModel: GlobalViewModel)  -> Global
    
    func nodeStats(viewModel: NodeStatViewModel)  -> NodeStat
    
    func printStats() 
    
    func setResetFlag() 
    
    func shutdown() 
    
}

open class AppHost:
    AppHostProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_apphost(self.pointer, $0) }
    }
public convenience init(config: AppConfig) {
    let pointer =
        try! rustCall() {
    uniffi_libgossip_fn_constructor_apphost_new(
        FfiConverterTypeAppConfig.lower(config),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_apphost(pointer, $0) }
    }

    

    
open func blobs() -> BlobDataDispatcher {
    return try!  FfiConverterTypeBlobDataDispatcher.lift(try! rustCall() {
    uniffi_libgossip_fn_method_apphost_blobs(self.uniffiClonePointer(),$0
    )
})
}
    
open func global(viewModel: GlobalViewModel) -> Global {
    return try!  FfiConverterTypeGlobal.lift(try! rustCall() {
    uniffi_libgossip_fn_method_apphost_global(self.uniffiClonePointer(),
        FfiConverterTypeGlobalViewModel.lower(viewModel),$0
    )
})
}
    
open func nodeStats(viewModel: NodeStatViewModel) -> NodeStat {
    return try!  FfiConverterTypeNodeStat.lift(try! rustCall() {
    uniffi_libgossip_fn_method_apphost_node_stats(self.uniffiClonePointer(),
        FfiConverterTypeNodeStatViewModel.lower(viewModel),$0
    )
})
}
    
open func printStats() {try! rustCall() {
    uniffi_libgossip_fn_method_apphost_print_stats(self.uniffiClonePointer(),$0
    )
}
}
    
open func setResetFlag() {try! rustCall() {
    uniffi_libgossip_fn_method_apphost_set_reset_flag(self.uniffiClonePointer(),$0
    )
}
}
    
open func shutdown() {try! rustCall() {
    uniffi_libgossip_fn_method_apphost_shutdown(self.uniffiClonePointer(),$0
    )
}
}
    

}

public struct FfiConverterTypeAppHost: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AppHost

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AppHost {
        return AppHost(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AppHost) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppHost {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AppHost, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeAppHost_lift(_ pointer: UnsafeMutableRawPointer) throws -> AppHost {
    return try FfiConverterTypeAppHost.lift(pointer)
}

public func FfiConverterTypeAppHost_lower(_ value: AppHost) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAppHost.lower(value)
}




public protocol BleGossipBroadcaster : AnyObject {
    
    func start() 
    
    func stop() 
    
    func setDocumentData(documentData: Data) 
    
    func setAddressData(addressData: Data) 
    
    func setPeerState(peerState: UInt8) 
    
}

open class BleGossipBroadcasterImpl:
    BleGossipBroadcaster {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_blegossipbroadcaster(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_blegossipbroadcaster(pointer, $0) }
    }

    

    
open func start() {try! rustCall() {
    uniffi_libgossip_fn_method_blegossipbroadcaster_start(self.uniffiClonePointer(),$0
    )
}
}
    
open func stop() {try! rustCall() {
    uniffi_libgossip_fn_method_blegossipbroadcaster_stop(self.uniffiClonePointer(),$0
    )
}
}
    
open func setDocumentData(documentData: Data) {try! rustCall() {
    uniffi_libgossip_fn_method_blegossipbroadcaster_set_document_data(self.uniffiClonePointer(),
        FfiConverterData.lower(documentData),$0
    )
}
}
    
open func setAddressData(addressData: Data) {try! rustCall() {
    uniffi_libgossip_fn_method_blegossipbroadcaster_set_address_data(self.uniffiClonePointer(),
        FfiConverterData.lower(addressData),$0
    )
}
}
    
open func setPeerState(peerState: UInt8) {try! rustCall() {
    uniffi_libgossip_fn_method_blegossipbroadcaster_set_peer_state(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(peerState),$0
    )
}
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBLEGossipBroadcaster {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceBleGossipBroadcaster = UniffiVTableCallbackInterfaceBleGossipBroadcaster(
        start: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBLEGossipBroadcaster.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.start(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        stop: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBLEGossipBroadcaster.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.stop(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        setDocumentData: { (
            uniffiHandle: UInt64,
            documentData: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBLEGossipBroadcaster.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.setDocumentData(
                     documentData: try FfiConverterData.lift(documentData)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        setAddressData: { (
            uniffiHandle: UInt64,
            addressData: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBLEGossipBroadcaster.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.setAddressData(
                     addressData: try FfiConverterData.lift(addressData)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        setPeerState: { (
            uniffiHandle: UInt64,
            peerState: UInt8,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBLEGossipBroadcaster.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.setPeerState(
                     peerState: try FfiConverterUInt8.lift(peerState)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeBLEGossipBroadcaster.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface BLEGossipBroadcaster: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitBLEGossipBroadcaster() {
    uniffi_libgossip_fn_init_callback_vtable_blegossipbroadcaster(&UniffiCallbackInterfaceBLEGossipBroadcaster.vtable)
}

public struct FfiConverterTypeBLEGossipBroadcaster: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<BleGossipBroadcaster>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BleGossipBroadcaster

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BleGossipBroadcaster {
        return BleGossipBroadcasterImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BleGossipBroadcaster) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BleGossipBroadcaster {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BleGossipBroadcaster, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBLEGossipBroadcaster_lift(_ pointer: UnsafeMutableRawPointer) throws -> BleGossipBroadcaster {
    return try FfiConverterTypeBLEGossipBroadcaster.lift(pointer)
}

public func FfiConverterTypeBLEGossipBroadcaster_lower(_ value: BleGossipBroadcaster) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBLEGossipBroadcaster.lower(value)
}




public protocol BleGossipScanner : AnyObject {
    
    func startScanning() 
    
    func stopScanning() 
    
    func setDelegate(delegate: GossipScannerDelegate) 
    
}

open class BleGossipScannerImpl:
    BleGossipScanner {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_blegossipscanner(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_blegossipscanner(pointer, $0) }
    }

    

    
open func startScanning() {try! rustCall() {
    uniffi_libgossip_fn_method_blegossipscanner_start_scanning(self.uniffiClonePointer(),$0
    )
}
}
    
open func stopScanning() {try! rustCall() {
    uniffi_libgossip_fn_method_blegossipscanner_stop_scanning(self.uniffiClonePointer(),$0
    )
}
}
    
open func setDelegate(delegate: GossipScannerDelegate) {try! rustCall() {
    uniffi_libgossip_fn_method_blegossipscanner_set_delegate(self.uniffiClonePointer(),
        FfiConverterTypeGossipScannerDelegate.lower(delegate),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBLEGossipScanner {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceBleGossipScanner = UniffiVTableCallbackInterfaceBleGossipScanner(
        startScanning: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBLEGossipScanner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.startScanning(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        stopScanning: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBLEGossipScanner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.stopScanning(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        setDelegate: { (
            uniffiHandle: UInt64,
            delegate: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBLEGossipScanner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.setDelegate(
                     delegate: try FfiConverterTypeGossipScannerDelegate.lift(delegate)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeBLEGossipScanner.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface BLEGossipScanner: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitBLEGossipScanner() {
    uniffi_libgossip_fn_init_callback_vtable_blegossipscanner(&UniffiCallbackInterfaceBLEGossipScanner.vtable)
}

public struct FfiConverterTypeBLEGossipScanner: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<BleGossipScanner>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BleGossipScanner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BleGossipScanner {
        return BleGossipScannerImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BleGossipScanner) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BleGossipScanner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BleGossipScanner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBLEGossipScanner_lift(_ pointer: UnsafeMutableRawPointer) throws -> BleGossipScanner {
    return try FfiConverterTypeBLEGossipScanner.lift(pointer)
}

public func FfiConverterTypeBLEGossipScanner_lower(_ value: BleGossipScanner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBLEGossipScanner.lower(value)
}




public protocol BlobDataDispatcherProtocol : AnyObject {
    
    func hydrate(bdr: BlobDataResponder) async 
    
}

open class BlobDataDispatcher:
    BlobDataDispatcherProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_blobdatadispatcher(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_blobdatadispatcher(pointer, $0) }
    }

    

    
open func hydrate(bdr: BlobDataResponder)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_blobdatadispatcher_hydrate(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBlobDataResponder.lower(bdr)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}

public struct FfiConverterTypeBlobDataDispatcher: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BlobDataDispatcher

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BlobDataDispatcher {
        return BlobDataDispatcher(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BlobDataDispatcher) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlobDataDispatcher {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BlobDataDispatcher, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBlobDataDispatcher_lift(_ pointer: UnsafeMutableRawPointer) throws -> BlobDataDispatcher {
    return try FfiConverterTypeBlobDataDispatcher.lift(pointer)
}

public func FfiConverterTypeBlobDataDispatcher_lower(_ value: BlobDataDispatcher) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBlobDataDispatcher.lower(value)
}




public protocol BlobDataResponder : AnyObject {
    
    func update(state: BlobDataState) async 
    
    func hash() async  -> WideId?
    
}

open class BlobDataResponderImpl:
    BlobDataResponder {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_blobdataresponder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_blobdataresponder(pointer, $0) }
    }

    

    
open func update(state: BlobDataState)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_blobdataresponder_update(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBlobDataState.lower(state)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func hash()async  -> WideId? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_blobdataresponder_hash(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_rust_buffer,
            completeFunc: ffi_libgossip_rust_future_complete_rust_buffer,
            freeFunc: ffi_libgossip_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeWideId.lift,
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBlobDataResponder {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceBlobDataResponder = UniffiVTableCallbackInterfaceBlobDataResponder(
        update: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBlobDataResponder.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.update(
                     state: try FfiConverterTypeBlobDataState.lift(state)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        hash: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> WideId? in
                guard let uniffiObj = try? FfiConverterTypeBlobDataResponder.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hash(
                )
            }

            let uniffiHandleSuccess = { (returnValue: WideId?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeWideId.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeBlobDataResponder.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface BlobDataResponder: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitBlobDataResponder() {
    uniffi_libgossip_fn_init_callback_vtable_blobdataresponder(&UniffiCallbackInterfaceBlobDataResponder.vtable)
}

public struct FfiConverterTypeBlobDataResponder: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<BlobDataResponder>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BlobDataResponder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BlobDataResponder {
        return BlobDataResponderImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BlobDataResponder) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlobDataResponder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BlobDataResponder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBlobDataResponder_lift(_ pointer: UnsafeMutableRawPointer) throws -> BlobDataResponder {
    return try FfiConverterTypeBlobDataResponder.lift(pointer)
}

public func FfiConverterTypeBlobDataResponder_lower(_ value: BlobDataResponder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBlobDataResponder.lower(value)
}




public protocol DeviceApiServiceProvider : AnyObject {
    
    func bleScanner()  -> BleGossipScanner
    
    func bleBroadcaster()  -> BleGossipBroadcaster
    
}

open class DeviceApiServiceProviderImpl:
    DeviceApiServiceProvider {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_deviceapiserviceprovider(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_deviceapiserviceprovider(pointer, $0) }
    }

    

    
open func bleScanner() -> BleGossipScanner {
    return try!  FfiConverterTypeBLEGossipScanner.lift(try! rustCall() {
    uniffi_libgossip_fn_method_deviceapiserviceprovider_ble_scanner(self.uniffiClonePointer(),$0
    )
})
}
    
open func bleBroadcaster() -> BleGossipBroadcaster {
    return try!  FfiConverterTypeBLEGossipBroadcaster.lift(try! rustCall() {
    uniffi_libgossip_fn_method_deviceapiserviceprovider_ble_broadcaster(self.uniffiClonePointer(),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceDeviceApiServiceProvider {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceDeviceApiServiceProvider = UniffiVTableCallbackInterfaceDeviceApiServiceProvider(
        bleScanner: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UnsafeMutableRawPointer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BleGossipScanner in
                guard let uniffiObj = try? FfiConverterTypeDeviceApiServiceProvider.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.bleScanner(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeBLEGossipScanner.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        bleBroadcaster: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UnsafeMutableRawPointer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BleGossipBroadcaster in
                guard let uniffiObj = try? FfiConverterTypeDeviceApiServiceProvider.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.bleBroadcaster(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeBLEGossipBroadcaster.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeDeviceApiServiceProvider.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface DeviceApiServiceProvider: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitDeviceApiServiceProvider() {
    uniffi_libgossip_fn_init_callback_vtable_deviceapiserviceprovider(&UniffiCallbackInterfaceDeviceApiServiceProvider.vtable)
}

public struct FfiConverterTypeDeviceApiServiceProvider: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<DeviceApiServiceProvider>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DeviceApiServiceProvider

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DeviceApiServiceProvider {
        return DeviceApiServiceProviderImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DeviceApiServiceProvider) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceApiServiceProvider {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DeviceApiServiceProvider, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeDeviceApiServiceProvider_lift(_ pointer: UnsafeMutableRawPointer) throws -> DeviceApiServiceProvider {
    return try FfiConverterTypeDeviceApiServiceProvider.lift(pointer)
}

public func FfiConverterTypeDeviceApiServiceProvider_lower(_ value: DeviceApiServiceProvider) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDeviceApiServiceProvider.lower(value)
}




public protocol GlobalProtocol : AnyObject {
    
    func leaveNearbyGroup() async throws 
    
    func loadNearbyPayload(hash: WideId, collectionDelegate: LoadCollectionDelegate) async 
    
    func sendMessage(text: String, payloadDir: String?) async 
    
    func setName(name: String) async throws 
    
    func setPic(picData: Data) async throws 
    
    func setScanning(shouldScan: Bool) async 
    
    func setStatus(status: String) async 
    
    func startSync() async throws 
    
}

open class Global:
    GlobalProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_global(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_global(pointer, $0) }
    }

    

    
open func leaveNearbyGroup()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_global_leave_nearby_group(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGossipError__as_error.lift
        )
}
    
open func loadNearbyPayload(hash: WideId, collectionDelegate: LoadCollectionDelegate)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_global_load_nearby_payload(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWideId.lower(hash),FfiConverterTypeLoadCollectionDelegate.lower(collectionDelegate)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func sendMessage(text: String, payloadDir: String?)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_global_send_message(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(text),FfiConverterOptionString.lower(payloadDir)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func setName(name: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_global_set_name(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGossipError__as_error.lift
        )
}
    
open func setPic(picData: Data)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_global_set_pic(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(picData)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGossipError__as_error.lift
        )
}
    
open func setScanning(shouldScan: Bool)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_global_set_scanning(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(shouldScan)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func setStatus(status: String)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_global_set_status(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(status)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func startSync()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_global_start_sync(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGossipError__as_error.lift
        )
}
    

}

public struct FfiConverterTypeGlobal: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Global

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Global {
        return Global(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Global) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Global {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Global, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeGlobal_lift(_ pointer: UnsafeMutableRawPointer) throws -> Global {
    return try FfiConverterTypeGlobal.lift(pointer)
}

public func FfiConverterTypeGlobal_lower(_ value: Global) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGlobal.lower(value)
}




public protocol GlobalViewModel : AnyObject {
    
    func nameUpdated(name: String) async 
    
    func picUpdated(pic: WideId) async 
    
    func scanningUpdated(scanning: Bool) async 
    
    func nearbyProfilesUpdated(profiles: [NearbyProfile]) async 
    
    func statusUpdated(status: Status) async 
    
    func debugStateUpdated(status: DebugState) async 
    
    func allMessagesUpdated(messages: [DisplayMessage]) async 
    
    func receivedOneMessage(message: DisplayMessage) async 
    
}

open class GlobalViewModelImpl:
    GlobalViewModel {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_globalviewmodel(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_globalviewmodel(pointer, $0) }
    }

    

    
open func nameUpdated(name: String)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_globalviewmodel_name_updated(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func picUpdated(pic: WideId)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_globalviewmodel_pic_updated(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWideId.lower(pic)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func scanningUpdated(scanning: Bool)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_globalviewmodel_scanning_updated(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(scanning)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func nearbyProfilesUpdated(profiles: [NearbyProfile])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_globalviewmodel_nearby_profiles_updated(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeNearbyProfile.lower(profiles)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func statusUpdated(status: Status)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_globalviewmodel_status_updated(
                    self.uniffiClonePointer(),
                    FfiConverterTypeStatus.lower(status)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func debugStateUpdated(status: DebugState)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_globalviewmodel_debug_state_updated(
                    self.uniffiClonePointer(),
                    FfiConverterTypeDebugState.lower(status)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func allMessagesUpdated(messages: [DisplayMessage])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_globalviewmodel_all_messages_updated(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeDisplayMessage.lower(messages)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func receivedOneMessage(message: DisplayMessage)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_globalviewmodel_received_one_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeDisplayMessage.lower(message)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceGlobalViewModel {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceGlobalViewModel = UniffiVTableCallbackInterfaceGlobalViewModel(
        nameUpdated: { (
            uniffiHandle: UInt64,
            name: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeGlobalViewModel.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.nameUpdated(
                     name: try FfiConverterString.lift(name)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        picUpdated: { (
            uniffiHandle: UInt64,
            pic: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeGlobalViewModel.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.picUpdated(
                     pic: try FfiConverterTypeWideId.lift(pic)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        scanningUpdated: { (
            uniffiHandle: UInt64,
            scanning: Int8,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeGlobalViewModel.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.scanningUpdated(
                     scanning: try FfiConverterBool.lift(scanning)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        nearbyProfilesUpdated: { (
            uniffiHandle: UInt64,
            profiles: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeGlobalViewModel.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.nearbyProfilesUpdated(
                     profiles: try FfiConverterSequenceTypeNearbyProfile.lift(profiles)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        statusUpdated: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeGlobalViewModel.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.statusUpdated(
                     status: try FfiConverterTypeStatus.lift(status)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        debugStateUpdated: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeGlobalViewModel.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.debugStateUpdated(
                     status: try FfiConverterTypeDebugState.lift(status)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        allMessagesUpdated: { (
            uniffiHandle: UInt64,
            messages: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeGlobalViewModel.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.allMessagesUpdated(
                     messages: try FfiConverterSequenceTypeDisplayMessage.lift(messages)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        receivedOneMessage: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeGlobalViewModel.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.receivedOneMessage(
                     message: try FfiConverterTypeDisplayMessage.lift(message)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeGlobalViewModel.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface GlobalViewModel: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitGlobalViewModel() {
    uniffi_libgossip_fn_init_callback_vtable_globalviewmodel(&UniffiCallbackInterfaceGlobalViewModel.vtable)
}

public struct FfiConverterTypeGlobalViewModel: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<GlobalViewModel>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GlobalViewModel

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GlobalViewModel {
        return GlobalViewModelImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GlobalViewModel) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GlobalViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeGlobalViewModel_lift(_ pointer: UnsafeMutableRawPointer) throws -> GlobalViewModel {
    return try FfiConverterTypeGlobalViewModel.lift(pointer)
}

public func FfiConverterTypeGlobalViewModel_lower(_ value: GlobalViewModel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGlobalViewModel.lower(value)
}




public protocol GossipErrorProtocol : AnyObject {
    
}

open class GossipError:
    Swift.Error,
    
    GossipErrorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_gossiperror(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_gossiperror(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeGossipError: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GossipError

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GossipError {
        return GossipError(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GossipError) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GossipError {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GossipError, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}



extension GossipError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public struct FfiConverterTypeGossipError__as_error: FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> GossipError {
        var reader = createReader(data: Data(rustBuffer: buf))
        return try FfiConverterTypeGossipError.read(from: &reader)
    }

    public static func lower(_ value: GossipError) -> RustBuffer {
        fatalError("not implemented")
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GossipError {
        fatalError("not implemented")
    }

    public static func write(_ value: GossipError, into buf: inout [UInt8]) {
        fatalError("not implemented")
    }
}


public func FfiConverterTypeGossipError_lift(_ pointer: UnsafeMutableRawPointer) throws -> GossipError {
    return try FfiConverterTypeGossipError.lift(pointer)
}

public func FfiConverterTypeGossipError_lower(_ value: GossipError) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGossipError.lower(value)
}




public protocol GossipScannerDelegateProtocol : AnyObject {
    
    func peerDataDiscovered(uuid: Uuid, addressData: Data, documentData: Data, peerState: UInt8) 
    
}

open class GossipScannerDelegate:
    GossipScannerDelegateProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_gossipscannerdelegate(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_gossipscannerdelegate(pointer, $0) }
    }

    

    
open func peerDataDiscovered(uuid: Uuid, addressData: Data, documentData: Data, peerState: UInt8) {try! rustCall() {
    uniffi_libgossip_fn_method_gossipscannerdelegate_peer_data_discovered(self.uniffiClonePointer(),
        FfiConverterTypeUUID.lower(uuid),
        FfiConverterData.lower(addressData),
        FfiConverterData.lower(documentData),
        FfiConverterUInt8.lower(peerState),$0
    )
}
}
    

}

public struct FfiConverterTypeGossipScannerDelegate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GossipScannerDelegate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GossipScannerDelegate {
        return GossipScannerDelegate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GossipScannerDelegate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GossipScannerDelegate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GossipScannerDelegate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeGossipScannerDelegate_lift(_ pointer: UnsafeMutableRawPointer) throws -> GossipScannerDelegate {
    return try FfiConverterTypeGossipScannerDelegate.lift(pointer)
}

public func FfiConverterTypeGossipScannerDelegate_lower(_ value: GossipScannerDelegate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGossipScannerDelegate.lower(value)
}




public protocol LoadCollectionDelegate : AnyObject {
    
    func update(state: CollectionState) async 
    
}

open class LoadCollectionDelegateImpl:
    LoadCollectionDelegate {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_loadcollectiondelegate(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_loadcollectiondelegate(pointer, $0) }
    }

    

    
open func update(state: CollectionState)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_loadcollectiondelegate_update(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCollectionState.lower(state)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLoadCollectionDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceLoadCollectionDelegate = UniffiVTableCallbackInterfaceLoadCollectionDelegate(
        update: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeLoadCollectionDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.update(
                     state: try FfiConverterTypeCollectionState.lift(state)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeLoadCollectionDelegate.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface LoadCollectionDelegate: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitLoadCollectionDelegate() {
    uniffi_libgossip_fn_init_callback_vtable_loadcollectiondelegate(&UniffiCallbackInterfaceLoadCollectionDelegate.vtable)
}

public struct FfiConverterTypeLoadCollectionDelegate: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<LoadCollectionDelegate>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LoadCollectionDelegate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LoadCollectionDelegate {
        return LoadCollectionDelegateImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LoadCollectionDelegate) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoadCollectionDelegate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LoadCollectionDelegate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeLoadCollectionDelegate_lift(_ pointer: UnsafeMutableRawPointer) throws -> LoadCollectionDelegate {
    return try FfiConverterTypeLoadCollectionDelegate.lift(pointer)
}

public func FfiConverterTypeLoadCollectionDelegate_lower(_ value: LoadCollectionDelegate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLoadCollectionDelegate.lower(value)
}




public protocol NodeStatProtocol : AnyObject {
    
}

open class NodeStat:
    NodeStatProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_nodestat(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_nodestat(pointer, $0) }
    }

    

    

}

public struct FfiConverterTypeNodeStat: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NodeStat

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NodeStat {
        return NodeStat(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NodeStat) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeStat {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NodeStat, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNodeStat_lift(_ pointer: UnsafeMutableRawPointer) throws -> NodeStat {
    return try FfiConverterTypeNodeStat.lift(pointer)
}

public func FfiConverterTypeNodeStat_lower(_ value: NodeStat) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNodeStat.lower(value)
}




public protocol NodeStatViewModel : AnyObject {
    
    func updateStats(stats: NodeStatsData) async 
    
}

open class NodeStatViewModelImpl:
    NodeStatViewModel {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_libgossip_fn_clone_nodestatviewmodel(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_libgossip_fn_free_nodestatviewmodel(pointer, $0) }
    }

    

    
open func updateStats(stats: NodeStatsData)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_libgossip_fn_method_nodestatviewmodel_update_stats(
                    self.uniffiClonePointer(),
                    FfiConverterTypeNodeStatsData.lower(stats)
                )
            },
            pollFunc: ffi_libgossip_rust_future_poll_void,
            completeFunc: ffi_libgossip_rust_future_complete_void,
            freeFunc: ffi_libgossip_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceNodeStatViewModel {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceNodeStatViewModel = UniffiVTableCallbackInterfaceNodeStatViewModel(
        updateStats: { (
            uniffiHandle: UInt64,
            stats: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeNodeStatViewModel.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.updateStats(
                     stats: try FfiConverterTypeNodeStatsData.lift(stats)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeNodeStatViewModel.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface NodeStatViewModel: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitNodeStatViewModel() {
    uniffi_libgossip_fn_init_callback_vtable_nodestatviewmodel(&UniffiCallbackInterfaceNodeStatViewModel.vtable)
}

public struct FfiConverterTypeNodeStatViewModel: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<NodeStatViewModel>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NodeStatViewModel

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NodeStatViewModel {
        return NodeStatViewModelImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NodeStatViewModel) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeStatViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NodeStatViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNodeStatViewModel_lift(_ pointer: UnsafeMutableRawPointer) throws -> NodeStatViewModel {
    return try FfiConverterTypeNodeStatViewModel.lift(pointer)
}

public func FfiConverterTypeNodeStatViewModel_lower(_ value: NodeStatViewModel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNodeStatViewModel.lower(value)
}


public struct AppConfig {
    public var dataPath: String
    public var logDirective: String?
    public var devApi: DeviceApiServiceProvider

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(dataPath: String, logDirective: String?, devApi: DeviceApiServiceProvider) {
        self.dataPath = dataPath
        self.logDirective = logDirective
        self.devApi = devApi
    }
}



public struct FfiConverterTypeAppConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppConfig {
        return
            try AppConfig(
                dataPath: FfiConverterString.read(from: &buf), 
                logDirective: FfiConverterOptionString.read(from: &buf), 
                devApi: FfiConverterTypeDeviceApiServiceProvider.read(from: &buf)
        )
    }

    public static func write(_ value: AppConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.dataPath, into: &buf)
        FfiConverterOptionString.write(value.logDirective, into: &buf)
        FfiConverterTypeDeviceApiServiceProvider.write(value.devApi, into: &buf)
    }
}


public func FfiConverterTypeAppConfig_lift(_ buf: RustBuffer) throws -> AppConfig {
    return try FfiConverterTypeAppConfig.lift(buf)
}

public func FfiConverterTypeAppConfig_lower(_ value: AppConfig) -> RustBuffer {
    return FfiConverterTypeAppConfig.lower(value)
}


public struct ConnectionStats {
    public var nodeId: WideId
    public var relayInfo: String
    public var connType: String
    public var addrs: [String]
    public var lastReceived: String
    public var hasSendAddr: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nodeId: WideId, relayInfo: String, connType: String, addrs: [String], lastReceived: String, hasSendAddr: Bool) {
        self.nodeId = nodeId
        self.relayInfo = relayInfo
        self.connType = connType
        self.addrs = addrs
        self.lastReceived = lastReceived
        self.hasSendAddr = hasSendAddr
    }
}



extension ConnectionStats: Equatable, Hashable {
    public static func ==(lhs: ConnectionStats, rhs: ConnectionStats) -> Bool {
        if lhs.nodeId != rhs.nodeId {
            return false
        }
        if lhs.relayInfo != rhs.relayInfo {
            return false
        }
        if lhs.connType != rhs.connType {
            return false
        }
        if lhs.addrs != rhs.addrs {
            return false
        }
        if lhs.lastReceived != rhs.lastReceived {
            return false
        }
        if lhs.hasSendAddr != rhs.hasSendAddr {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodeId)
        hasher.combine(relayInfo)
        hasher.combine(connType)
        hasher.combine(addrs)
        hasher.combine(lastReceived)
        hasher.combine(hasSendAddr)
    }
}


public struct FfiConverterTypeConnectionStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionStats {
        return
            try ConnectionStats(
                nodeId: FfiConverterTypeWideId.read(from: &buf), 
                relayInfo: FfiConverterString.read(from: &buf), 
                connType: FfiConverterString.read(from: &buf), 
                addrs: FfiConverterSequenceString.read(from: &buf), 
                lastReceived: FfiConverterString.read(from: &buf), 
                hasSendAddr: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ConnectionStats, into buf: inout [UInt8]) {
        FfiConverterTypeWideId.write(value.nodeId, into: &buf)
        FfiConverterString.write(value.relayInfo, into: &buf)
        FfiConverterString.write(value.connType, into: &buf)
        FfiConverterSequenceString.write(value.addrs, into: &buf)
        FfiConverterString.write(value.lastReceived, into: &buf)
        FfiConverterBool.write(value.hasSendAddr, into: &buf)
    }
}


public func FfiConverterTypeConnectionStats_lift(_ buf: RustBuffer) throws -> ConnectionStats {
    return try FfiConverterTypeConnectionStats.lift(buf)
}

public func FfiConverterTypeConnectionStats_lower(_ value: ConnectionStats) -> RustBuffer {
    return FfiConverterTypeConnectionStats.lower(value)
}


public struct DebugState {
    public var docId: String
    public var foundGroup: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(docId: String, foundGroup: Bool) {
        self.docId = docId
        self.foundGroup = foundGroup
    }
}



extension DebugState: Equatable, Hashable {
    public static func ==(lhs: DebugState, rhs: DebugState) -> Bool {
        if lhs.docId != rhs.docId {
            return false
        }
        if lhs.foundGroup != rhs.foundGroup {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(docId)
        hasher.combine(foundGroup)
    }
}


public struct FfiConverterTypeDebugState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DebugState {
        return
            try DebugState(
                docId: FfiConverterString.read(from: &buf), 
                foundGroup: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: DebugState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.docId, into: &buf)
        FfiConverterBool.write(value.foundGroup, into: &buf)
    }
}


public func FfiConverterTypeDebugState_lift(_ buf: RustBuffer) throws -> DebugState {
    return try FfiConverterTypeDebugState.lift(buf)
}

public func FfiConverterTypeDebugState_lower(_ value: DebugState) -> RustBuffer {
    return FfiConverterTypeDebugState.lower(value)
}


public struct DisplayMessage {
    public var id: UInt32
    public var text: String
    public var isSelf: Bool
    public var payload: WideId?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt32, text: String, isSelf: Bool, payload: WideId?) {
        self.id = id
        self.text = text
        self.isSelf = isSelf
        self.payload = payload
    }
}



extension DisplayMessage: Equatable, Hashable {
    public static func ==(lhs: DisplayMessage, rhs: DisplayMessage) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        if lhs.isSelf != rhs.isSelf {
            return false
        }
        if lhs.payload != rhs.payload {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(text)
        hasher.combine(isSelf)
        hasher.combine(payload)
    }
}


public struct FfiConverterTypeDisplayMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DisplayMessage {
        return
            try DisplayMessage(
                id: FfiConverterUInt32.read(from: &buf), 
                text: FfiConverterString.read(from: &buf), 
                isSelf: FfiConverterBool.read(from: &buf), 
                payload: FfiConverterOptionTypeWideId.read(from: &buf)
        )
    }

    public static func write(_ value: DisplayMessage, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.id, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterBool.write(value.isSelf, into: &buf)
        FfiConverterOptionTypeWideId.write(value.payload, into: &buf)
    }
}


public func FfiConverterTypeDisplayMessage_lift(_ buf: RustBuffer) throws -> DisplayMessage {
    return try FfiConverterTypeDisplayMessage.lift(buf)
}

public func FfiConverterTypeDisplayMessage_lower(_ value: DisplayMessage) -> RustBuffer {
    return FfiConverterTypeDisplayMessage.lower(value)
}


public struct Identity {
    public var name: String
    public var pk: WideId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, pk: WideId) {
        self.name = name
        self.pk = pk
    }
}



extension Identity: Equatable, Hashable {
    public static func ==(lhs: Identity, rhs: Identity) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.pk != rhs.pk {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(pk)
    }
}


public struct FfiConverterTypeIdentity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Identity {
        return
            try Identity(
                name: FfiConverterString.read(from: &buf), 
                pk: FfiConverterTypeWideId.read(from: &buf)
        )
    }

    public static func write(_ value: Identity, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeWideId.write(value.pk, into: &buf)
    }
}


public func FfiConverterTypeIdentity_lift(_ buf: RustBuffer) throws -> Identity {
    return try FfiConverterTypeIdentity.lift(buf)
}

public func FfiConverterTypeIdentity_lower(_ value: Identity) -> RustBuffer {
    return FfiConverterTypeIdentity.lower(value)
}


public struct NamedBlob {
    public var name: String
    public var hash: WideId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, hash: WideId) {
        self.name = name
        self.hash = hash
    }
}



extension NamedBlob: Equatable, Hashable {
    public static func ==(lhs: NamedBlob, rhs: NamedBlob) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(hash)
    }
}


public struct FfiConverterTypeNamedBlob: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NamedBlob {
        return
            try NamedBlob(
                name: FfiConverterString.read(from: &buf), 
                hash: FfiConverterTypeWideId.read(from: &buf)
        )
    }

    public static func write(_ value: NamedBlob, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeWideId.write(value.hash, into: &buf)
    }
}


public func FfiConverterTypeNamedBlob_lift(_ buf: RustBuffer) throws -> NamedBlob {
    return try FfiConverterTypeNamedBlob.lift(buf)
}

public func FfiConverterTypeNamedBlob_lower(_ value: NamedBlob) -> RustBuffer {
    return FfiConverterTypeNamedBlob.lower(value)
}


public struct NearbyProfile {
    public var pk: WideId
    public var name: String
    public var pic: WideId?
    public var status: Status

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pk: WideId, name: String, pic: WideId?, status: Status) {
        self.pk = pk
        self.name = name
        self.pic = pic
        self.status = status
    }
}



extension NearbyProfile: Equatable, Hashable {
    public static func ==(lhs: NearbyProfile, rhs: NearbyProfile) -> Bool {
        if lhs.pk != rhs.pk {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.pic != rhs.pic {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pk)
        hasher.combine(name)
        hasher.combine(pic)
        hasher.combine(status)
    }
}


public struct FfiConverterTypeNearbyProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NearbyProfile {
        return
            try NearbyProfile(
                pk: FfiConverterTypeWideId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                pic: FfiConverterOptionTypeWideId.read(from: &buf), 
                status: FfiConverterTypeStatus.read(from: &buf)
        )
    }

    public static func write(_ value: NearbyProfile, into buf: inout [UInt8]) {
        FfiConverterTypeWideId.write(value.pk, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionTypeWideId.write(value.pic, into: &buf)
        FfiConverterTypeStatus.write(value.status, into: &buf)
    }
}


public func FfiConverterTypeNearbyProfile_lift(_ buf: RustBuffer) throws -> NearbyProfile {
    return try FfiConverterTypeNearbyProfile.lift(buf)
}

public func FfiConverterTypeNearbyProfile_lower(_ value: NearbyProfile) -> RustBuffer {
    return FfiConverterTypeNearbyProfile.lower(value)
}


public struct NodeStatsData {
    public var nodeId: WideId
    public var relayUrl: String
    public var listenAddrs: [String]
    public var connections: [ConnectionStats]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nodeId: WideId, relayUrl: String, listenAddrs: [String], connections: [ConnectionStats]) {
        self.nodeId = nodeId
        self.relayUrl = relayUrl
        self.listenAddrs = listenAddrs
        self.connections = connections
    }
}



extension NodeStatsData: Equatable, Hashable {
    public static func ==(lhs: NodeStatsData, rhs: NodeStatsData) -> Bool {
        if lhs.nodeId != rhs.nodeId {
            return false
        }
        if lhs.relayUrl != rhs.relayUrl {
            return false
        }
        if lhs.listenAddrs != rhs.listenAddrs {
            return false
        }
        if lhs.connections != rhs.connections {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodeId)
        hasher.combine(relayUrl)
        hasher.combine(listenAddrs)
        hasher.combine(connections)
    }
}


public struct FfiConverterTypeNodeStatsData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeStatsData {
        return
            try NodeStatsData(
                nodeId: FfiConverterTypeWideId.read(from: &buf), 
                relayUrl: FfiConverterString.read(from: &buf), 
                listenAddrs: FfiConverterSequenceString.read(from: &buf), 
                connections: FfiConverterSequenceTypeConnectionStats.read(from: &buf)
        )
    }

    public static func write(_ value: NodeStatsData, into buf: inout [UInt8]) {
        FfiConverterTypeWideId.write(value.nodeId, into: &buf)
        FfiConverterString.write(value.relayUrl, into: &buf)
        FfiConverterSequenceString.write(value.listenAddrs, into: &buf)
        FfiConverterSequenceTypeConnectionStats.write(value.connections, into: &buf)
    }
}


public func FfiConverterTypeNodeStatsData_lift(_ buf: RustBuffer) throws -> NodeStatsData {
    return try FfiConverterTypeNodeStatsData.lift(buf)
}

public func FfiConverterTypeNodeStatsData_lower(_ value: NodeStatsData) -> RustBuffer {
    return FfiConverterTypeNodeStatsData.lower(value)
}


public struct Status {
    public var text: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(text: String) {
        self.text = text
    }
}



extension Status: Equatable, Hashable {
    public static func ==(lhs: Status, rhs: Status) -> Bool {
        if lhs.text != rhs.text {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(text)
    }
}


public struct FfiConverterTypeStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Status {
        return
            try Status(
                text: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Status, into buf: inout [UInt8]) {
        FfiConverterString.write(value.text, into: &buf)
    }
}


public func FfiConverterTypeStatus_lift(_ buf: RustBuffer) throws -> Status {
    return try FfiConverterTypeStatus.lift(buf)
}

public func FfiConverterTypeStatus_lower(_ value: Status) -> RustBuffer {
    return FfiConverterTypeStatus.lower(value)
}


public struct Uuid {
    public var p1: UInt64
    public var p2: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(p1: UInt64, p2: UInt64) {
        self.p1 = p1
        self.p2 = p2
    }
}



extension Uuid: Equatable, Hashable {
    public static func ==(lhs: Uuid, rhs: Uuid) -> Bool {
        if lhs.p1 != rhs.p1 {
            return false
        }
        if lhs.p2 != rhs.p2 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(p1)
        hasher.combine(p2)
    }
}


public struct FfiConverterTypeUUID: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
        return
            try Uuid(
                p1: FfiConverterUInt64.read(from: &buf), 
                p2: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Uuid, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.p1, into: &buf)
        FfiConverterUInt64.write(value.p2, into: &buf)
    }
}


public func FfiConverterTypeUUID_lift(_ buf: RustBuffer) throws -> Uuid {
    return try FfiConverterTypeUUID.lift(buf)
}

public func FfiConverterTypeUUID_lower(_ value: Uuid) -> RustBuffer {
    return FfiConverterTypeUUID.lower(value)
}


public struct WideId {
    public var p1: UInt64
    public var p2: UInt64
    public var p3: UInt64
    public var p4: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(p1: UInt64, p2: UInt64, p3: UInt64, p4: UInt64) {
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3
        self.p4 = p4
    }
}



extension WideId: Equatable, Hashable {
    public static func ==(lhs: WideId, rhs: WideId) -> Bool {
        if lhs.p1 != rhs.p1 {
            return false
        }
        if lhs.p2 != rhs.p2 {
            return false
        }
        if lhs.p3 != rhs.p3 {
            return false
        }
        if lhs.p4 != rhs.p4 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(p1)
        hasher.combine(p2)
        hasher.combine(p3)
        hasher.combine(p4)
    }
}


public struct FfiConverterTypeWideId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WideId {
        return
            try WideId(
                p1: FfiConverterUInt64.read(from: &buf), 
                p2: FfiConverterUInt64.read(from: &buf), 
                p3: FfiConverterUInt64.read(from: &buf), 
                p4: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: WideId, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.p1, into: &buf)
        FfiConverterUInt64.write(value.p2, into: &buf)
        FfiConverterUInt64.write(value.p3, into: &buf)
        FfiConverterUInt64.write(value.p4, into: &buf)
    }
}


public func FfiConverterTypeWideId_lift(_ buf: RustBuffer) throws -> WideId {
    return try FfiConverterTypeWideId.lift(buf)
}

public func FfiConverterTypeWideId_lower(_ value: WideId) -> RustBuffer {
    return FfiConverterTypeWideId.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BlobDataState {
    
    case empty
    case loading
    case loaded(WideId,Data
    )
    case failed(String
    )
}


public struct FfiConverterTypeBlobDataState: FfiConverterRustBuffer {
    typealias SwiftType = BlobDataState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlobDataState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .empty
        
        case 2: return .loading
        
        case 3: return .loaded(try FfiConverterTypeWideId.read(from: &buf), try FfiConverterData.read(from: &buf)
        )
        
        case 4: return .failed(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BlobDataState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .empty:
            writeInt(&buf, Int32(1))
        
        
        case .loading:
            writeInt(&buf, Int32(2))
        
        
        case let .loaded(v1,v2):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWideId.write(v1, into: &buf)
            FfiConverterData.write(v2, into: &buf)
            
        
        case let .failed(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeBlobDataState_lift(_ buf: RustBuffer) throws -> BlobDataState {
    return try FfiConverterTypeBlobDataState.lift(buf)
}

public func FfiConverterTypeBlobDataState_lower(_ value: BlobDataState) -> RustBuffer {
    return FfiConverterTypeBlobDataState.lower(value)
}



extension BlobDataState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CollectionState {
    
    case empty
    case loading
    case loaded([NamedBlob]
    )
    case failed(String
    )
}


public struct FfiConverterTypeCollectionState: FfiConverterRustBuffer {
    typealias SwiftType = CollectionState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .empty
        
        case 2: return .loading
        
        case 3: return .loaded(try FfiConverterSequenceTypeNamedBlob.read(from: &buf)
        )
        
        case 4: return .failed(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CollectionState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .empty:
            writeInt(&buf, Int32(1))
        
        
        case .loading:
            writeInt(&buf, Int32(2))
        
        
        case let .loaded(v1):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeNamedBlob.write(v1, into: &buf)
            
        
        case let .failed(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeCollectionState_lift(_ buf: RustBuffer) throws -> CollectionState {
    return try FfiConverterTypeCollectionState.lift(buf)
}

public func FfiConverterTypeCollectionState_lower(_ value: CollectionState) -> RustBuffer {
    return FfiConverterTypeCollectionState.lower(value)
}



extension CollectionState: Equatable, Hashable {}



fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWideId: FfiConverterRustBuffer {
    typealias SwiftType = WideId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWideId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWideId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeConnectionStats: FfiConverterRustBuffer {
    typealias SwiftType = [ConnectionStats]

    public static func write(_ value: [ConnectionStats], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeConnectionStats.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ConnectionStats] {
        let len: Int32 = try readInt(&buf)
        var seq = [ConnectionStats]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeConnectionStats.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDisplayMessage: FfiConverterRustBuffer {
    typealias SwiftType = [DisplayMessage]

    public static func write(_ value: [DisplayMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDisplayMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DisplayMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [DisplayMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDisplayMessage.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNamedBlob: FfiConverterRustBuffer {
    typealias SwiftType = [NamedBlob]

    public static func write(_ value: [NamedBlob], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNamedBlob.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NamedBlob] {
        let len: Int32 = try readInt(&buf)
        var seq = [NamedBlob]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNamedBlob.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNearbyProfile: FfiConverterRustBuffer {
    typealias SwiftType = [NearbyProfile]

    public static func write(_ value: [NearbyProfile], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNearbyProfile.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NearbyProfile] {
        let len: Int32 = try readInt(&buf)
        var seq = [NearbyProfile]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNearbyProfile.read(from: &buf))
        }
        return seq
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountLibgossip() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
public func createDummyProvider() -> DeviceApiServiceProvider {
    return try!  FfiConverterTypeDeviceApiServiceProvider.lift(try! rustCall() {
    uniffi_libgossip_fn_func_create_dummy_provider($0
    )
})
}
public func uuidFromBytes(b1: UInt8, b2: UInt8, b3: UInt8, b4: UInt8, b5: UInt8, b6: UInt8, b7: UInt8, b8: UInt8, b9: UInt8, b10: UInt8, b11: UInt8, b12: UInt8, b13: UInt8, b14: UInt8, b15: UInt8, b16: UInt8) -> Uuid {
    return try!  FfiConverterTypeUUID.lift(try! rustCall() {
    uniffi_libgossip_fn_func_uuid_from_bytes(
        FfiConverterUInt8.lower(b1),
        FfiConverterUInt8.lower(b2),
        FfiConverterUInt8.lower(b3),
        FfiConverterUInt8.lower(b4),
        FfiConverterUInt8.lower(b5),
        FfiConverterUInt8.lower(b6),
        FfiConverterUInt8.lower(b7),
        FfiConverterUInt8.lower(b8),
        FfiConverterUInt8.lower(b9),
        FfiConverterUInt8.lower(b10),
        FfiConverterUInt8.lower(b11),
        FfiConverterUInt8.lower(b12),
        FfiConverterUInt8.lower(b13),
        FfiConverterUInt8.lower(b14),
        FfiConverterUInt8.lower(b15),
        FfiConverterUInt8.lower(b16),$0
    )
})
}
public func wideidToString(wideId: WideId) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_libgossip_fn_func_wideid_to_string(
        FfiConverterTypeWideId.lower(wideId),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_libgossip_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_libgossip_checksum_func_create_dummy_provider() != 37734) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_func_uuid_from_bytes() != 24432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_func_wideid_to_string() != 59181) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_apphost_blobs() != 54788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_apphost_global() != 14824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_apphost_node_stats() != 31707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_apphost_print_stats() != 39813) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_apphost_set_reset_flag() != 35834) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_apphost_shutdown() != 53615) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_blegossipbroadcaster_start() != 22919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_blegossipbroadcaster_stop() != 28107) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_blegossipbroadcaster_set_document_data() != 9435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_blegossipbroadcaster_set_address_data() != 61301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_blegossipbroadcaster_set_peer_state() != 1095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_blegossipscanner_start_scanning() != 38137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_blegossipscanner_stop_scanning() != 63535) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_blegossipscanner_set_delegate() != 65126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_blobdatadispatcher_hydrate() != 64004) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_blobdataresponder_update() != 3853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_blobdataresponder_hash() != 55646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_deviceapiserviceprovider_ble_scanner() != 13248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_deviceapiserviceprovider_ble_broadcaster() != 57331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_global_leave_nearby_group() != 56528) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_global_load_nearby_payload() != 46010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_global_send_message() != 55434) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_global_set_name() != 35062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_global_set_pic() != 27588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_global_set_scanning() != 14000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_global_set_status() != 13192) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_global_start_sync() != 29723) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_globalviewmodel_name_updated() != 25051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_globalviewmodel_pic_updated() != 8611) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_globalviewmodel_scanning_updated() != 59888) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_globalviewmodel_nearby_profiles_updated() != 641) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_globalviewmodel_status_updated() != 65486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_globalviewmodel_debug_state_updated() != 25085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_globalviewmodel_all_messages_updated() != 61396) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_globalviewmodel_received_one_message() != 1113) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_gossipscannerdelegate_peer_data_discovered() != 4720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_loadcollectiondelegate_update() != 56170) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_method_nodestatviewmodel_update_stats() != 45677) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_libgossip_checksum_constructor_apphost_new() != 10874) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitBLEGossipBroadcaster()
    uniffiCallbackInitBLEGossipScanner()
    uniffiCallbackInitBlobDataResponder()
    uniffiCallbackInitDeviceApiServiceProvider()
    uniffiCallbackInitGlobalViewModel()
    uniffiCallbackInitLoadCollectionDelegate()
    uniffiCallbackInitNodeStatViewModel()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all